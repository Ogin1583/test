<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>簡易・山手線 クリック塗りアプリ</title>
  <style>
    body { font-family: system-ui, sans-serif; display: grid; place-items: center; gap: 10px; margin: 20px; }
    #toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    #map { border: 1px solid #bbb; background:#f8f8f8; cursor: pointer; border-radius: 8px; }
    .stat { font-size: 14px; color: #333; }
    button { padding: 6px 12px; border: 1px solid #aaa; border-radius: 6px; background: #fff; }
    button:hover { background:#f0f0f0; }
  </style>
</head>
<body>
  <h1>簡易・山手線（クリックで区間を塗る）</h1>

  <div id="toolbar">
    <button id="saveBtn">保存</button>
    <button id="loadBtn">読込</button>
    <button id="clearBtn">全解除</button>
    <span class="stat">塗った区間: <span id="count">0</span> / <span id="total">0</span></span>
  </div>

  <canvas id="map" width="800" height="800"></canvas>

  <script>
    // ====== 路線データ ======
  const lineData = {
    "yamanote": {
      name: "山手線",
      stations: [
        "東京","有楽町","新橋","浜松町","田町","高輪ゲートウェイ","品川","大崎","五反田","目黒",
        "恵比寿","渋谷","原宿","代々木","新宿","新大久保","高田馬場","目白","池袋","大塚",
        "巣鴨","駒込","田端","西日暮里","日暮里","鶯谷","上野","御徒町","秋葉原","神田"
      ],
      color: "#2e8b57",
      layout: "circular",
      topStation: "駒込"
    },
    "chuo-rapid": {
      name: "中央線（快速）",
      stations: [ "三鷹", "吉祥寺", "西荻窪", "荻窪", "阿佐ヶ谷", "高円寺", "中野", "新宿", "四ツ谷", "御茶ノ水", "神田", "東京" ],
      color: "#dd4d2c",
      layout: "custom-chuo"
    }
  };

  // ====== 描画・状態管理用のデータ ======
  const allStations = new Map();
  const lines = {};

  // ====== レイアウト設定 ======
  const canvas = document.getElementById("map");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  // ====== ビューポート（視点）管理 ======
  const view = {
    x: 0,
    y: 0,
    scale: 1,
    minScale: 0.2,
    maxScale: 5,
  };
  let isDragging = false;
  let lastMousePos = { x: 0, y: 0 };
  canvas.style.cursor = "grab";


  // 極座標→XY
  function polar(angleRad, radius) {
    return { x: cx + radius * Math.cos(angleRad), y: cy + radius * Math.sin(angleRad) };
  }

  // 路線データをセットアップする
  function setupLines() {
    const lineKeys = Object.keys(lineData).sort((a, b) => (lineData[a].layout === 'circular' ? -1 : 1));

    for (const lineKey of lineKeys) {
      const data = lineData[lineKey];
      const stationNames = data.stations;
      const N = stationNames.length;
      const lineStations = [], lineEdges = [];

      if (data.layout === 'circular') {
        const R = 290;
        const topStationIndex = data.topStation ? stationNames.indexOf(data.topStation) : 0;
        const angleOffset = (topStationIndex >= 0) ? -topStationIndex * (2 * Math.PI / N) : 0;
        for (let i = 0; i < N; i++) {
          const stationName = stationNames[i];
          const theta = (-Math.PI/2) + angleOffset + i * (2*Math.PI/N);
          if (!allStations.has(stationName)) {
            const p = polar(theta, R);
            allStations.set(stationName, { name: stationName, x: p.x, y: p.y, angle: theta, radius: R, layout: 'circular' });
          }
          lineStations.push(allStations.get(stationName));
        }
      } else if (data.layout === 'custom-chuo') {
        const shinjukuIdx = stationNames.indexOf("新宿");
        const shinjukuStation = allStations.get("新宿");
        const angle = shinjukuStation.angle;
        const stepR = 30;
        for (let i = 0; i < shinjukuIdx; i++) {
          const stationName = stationNames[i];
          const radius = shinjukuStation.radius + (shinjukuIdx - i) * stepR;
          const p = polar(angle, radius);
          allStations.set(stationName, { name: stationName, x: p.x, y: p.y, angle: angle, radius: radius, layout: 'custom-chuo-outer' });
          lineStations.push(allStations.get(stationName));
        }
        lineStations.push(shinjukuStation);
        const tokyoStation = allStations.get("東京");
        const innerStations = stationNames.slice(shinjukuIdx + 1);
        const innerN = innerStations.length + 1;
        innerStations.forEach((stationName, i) => {
          const t = (i + 1) / innerN;
          if (!allStations.has(stationName)) {
            const x = (1 - t) * shinjukuStation.x + t * tokyoStation.x;
            const y = (1 - t) * shinjukuStation.y + t * tokyoStation.y;
            allStations.set(stationName, { name: stationName, x: x, y: y, layout: 'custom-chuo-inner' });
          }
          lineStations.push(allStations.get(stationName));
        });
      }
      
      lineStations.sort((a, b) => stationNames.indexOf(a.name) - stationNames.indexOf(b.name));

      for (let i = 0; i < N - 1; i++) {
        lineEdges.push({ from: lineStations[i], to: lineStations[i+1], color: data.color, active: false });
      }
      if (data.layout === 'circular' && N > 1) {
        lineEdges.push({ from: lineStations[N-1], to: lineStations[0], color: data.color, active: false });
      }
      lines[lineKey] = { name: data.name, stations: lineStations, edges: lineEdges, layout: data.layout };
    }
  }

  // ====== 描画 ======
  function draw() {
    ctx.clearRect(0, 0, W, H);

    // ビューポートの変形を適用
    ctx.save();
    ctx.translate(view.x, view.y);
    ctx.scale(view.scale, view.scale);

    // 路線図の描画
    let totalEdges = 0, activeEdges = 0;
    for (const lineKey in lines) {
      lines[lineKey].edges.forEach(e => {
        const a = e.from, b = e.to;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.lineWidth = 10 / view.scale; // ズームしても線の太さが変わらないように調整
        ctx.lineCap = "round";
        ctx.strokeStyle = e.active ? "#d33" : e.color;
        ctx.stroke();
        totalEdges++;
        if (e.active) activeEdges++;
      });
    }

    allStations.forEach(s => {
      ctx.beginPath();
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2 / view.scale;
      ctx.arc(s.x, s.y, 6 / view.scale, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    });

    ctx.font = `${12 / view.scale}px system-ui, sans-serif`;
    ctx.fillStyle = "#111";
    ctx.textBaseline = "middle";
    allStations.forEach(s => {
      if (s.layout === 'circular' || s.layout === 'custom-chuo-outer') {
        const labelR = s.radius + (s.layout === 'circular' ? 22 : 15) / view.scale;
        const label = polar(s.angle, labelR);
        const deg = ((s.angle*180/Math.PI)+360)%360;
        ctx.textAlign = (deg > 90 && deg < 270) ? "right" : "left";
        ctx.fillText(s.name, label.x, label.y);
      } else {
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText(s.name, s.x, s.y + 10 / view.scale);
      }
    });
    
    // 変形をリセット
    ctx.restore();

    // 統計情報（UIは変形の影響を受けない）
    document.getElementById("count").textContent = activeEdges;
    document.getElementById("total").textContent = totalEdges;
  }

  // ====== イベント処理 ======
  // スクリーン座標をワールド座標（描画座標）に変換
  function screenToWorld(x, y) {
    return {
      x: (x - view.x) / view.scale,
      y: (y - view.y) / view.scale,
    };
  }

  function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
    const vx = x2 - x1, vy = y2 - y1;
    const wx = px - x1, wy = py - y1;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(px - x1, py - y1);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px - x2, py - y2);
    const t = c1 / c2;
    const projx = x1 + t*vx, projy = y1 + t*vy;
    return Math.hypot(px - projx, py - projy);
  }

  // クリックイベント（ドラッグ終了時に判定）
  let clickTimeout = null;
  canvas.addEventListener("mousedown", (ev) => {
      isDragging = false; // ドラッグ開始前はfalse
      // 短いmousedown/mouseupをclickとみなすためのタイマー
      clickTimeout = setTimeout(() => {
          isDragging = true;
          canvas.style.cursor = "grabbing";
          lastMousePos = { x: ev.clientX, y: ev.clientY };
      }, 150); // 150ms以上押したらドラッグとみなす
  });

  canvas.addEventListener("mouseup", (ev) => {
      clearTimeout(clickTimeout);
      if (!isDragging) { // ドラッグでなければクリック処理
          const rect = canvas.getBoundingClientRect();
          const worldPos = screenToWorld(ev.clientX - rect.left, ev.clientY - rect.top);
          
          let bestEdge = null, bestDist = Infinity;
          for (const lineKey in lines) {
              lines[lineKey].edges.forEach(e => {
                  const a = e.from, b = e.to;
                  const d = pointToSegmentDistance(worldPos.x, worldPos.y, a.x, a.y, b.x, b.y);
                  if (d < bestDist) {
                      bestDist = d;
                      bestEdge = e;
                  }
              });
          }
          if (bestEdge && bestDist <= 12 / view.scale) {
              bestEdge.active = !bestEdge.active;
          }
      }
      isDragging = false;
      canvas.style.cursor = "grab";
      draw();
  });

  canvas.addEventListener("mousemove", (ev) => {
    if (!isDragging) return;
    const dx = ev.clientX - lastMousePos.x;
    const dy = ev.clientY - lastMousePos.y;
    view.x += dx;
    view.y += dy;
    lastMousePos = { x: ev.clientX, y: ev.clientY };
    draw();
  });

  canvas.addEventListener("wheel", (ev) => {
    ev.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouse = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
    
    const worldPosBeforeZoom = screenToWorld(mouse.x, mouse.y);
    
    const zoomFactor = ev.deltaY < 0 ? 1.1 : 1 / 1.1;
    const newScale = view.scale * zoomFactor;
    view.scale = Math.max(view.minScale, Math.min(view.maxScale, newScale));
    
    const worldPosAfterZoom = screenToWorld(mouse.x, mouse.y);

    view.x += (worldPosAfterZoom.x - worldPosBeforeZoom.x) * view.scale;
    view.y += (worldPosAfterZoom.y - worldPosBeforeZoom.y) * view.scale;
    
    draw();
  });


  // ====== 保存/読込/全解除 ======
  const STORAGE_KEY = "multi_line_map_state_v5";

  document.getElementById("saveBtn").onclick = () => {
    const state = {};
    for (const lineKey in lines) {
      state[lineKey] = lines[lineKey].edges.map(e => e.active ? 1 : 0);
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    alert("保存しました。");
  };

  document.getElementById("loadBtn").onclick = () => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) { alert("保存データがありません。"); return; }
    try {
      const state = JSON.parse(raw);
      for (const lineKey in state) {
        if (lines[lineKey] && state[lineKey]) {
          lines[lineKey].edges.forEach((e, i) => {
            if(state[lineKey][i] !== undefined) e.active = !!state[lineKey][i];
          });
        }
      }
      draw();
      alert("読込完了。");
    } catch {
      alert("保存データの読み込みに失敗しました。");
    }
  };

  document.getElementById("clearBtn").onclick = () => {
    for (const lineKey in lines) {
      lines[lineKey].edges.forEach(e => e.active = false);
    }
    draw();
  };

  // ====== 初期化処理 ======
  setupLines();
  draw();
  </script>
</body>
</html>
